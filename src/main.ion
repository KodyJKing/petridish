const
    {Matter, Creature, Common} = import './'
    {Engine, Render, World, Bodies, Mouse, MouseConstraint, Composite, Events} = Matter
    {random} = Common

export ->
    let
        PADDING = 10
        WIDTH = window.innerWidth - PADDING * 2
        HEIGHT = window.innerHeight - PADDING * 2
        HALFWIDTH = WIDTH / 2
        HALFHEIGHT = HEIGHT / 2

        engine = Engine.create()
        world = engine.world
        render = Render.create(..)
            engine: engine
            element: document.body
            options:
                width: WIDTH
                height: HEIGHT
                wireframes: false
                # showAngleIndicator: true
                # showBroadphase: true
                background: '#272822'

        mouse = Mouse.create(render.canvas)

    window.engine = engine
    window.world = world

    engine.broadphase.bucketHeight = 20
    engine.broadphase.bucketWidth = 20

    world.gravity.y = 0

    Engine.run(engine)
    Render.run(render)

    World.add(..)
        world, MouseConstraint.create(..)
            engine, {}
                mouse: mouse
                constraint:
                    render: {visible: false}
                    stiffness: 0.05
                    damping: 0.1

    #  Walls
    let wallOpt = { isStatic: true, render: { fillStyle: '#383830' } }
    World.add(..)
        world
        []
            Bodies.rectangle(..)
                0,         HALFHEIGHT, 60,    HEIGHT, wallOpt
            Bodies.rectangle(..)
                WIDTH,     HALFHEIGHT, 60,    HEIGHT, wallOpt
            Bodies.rectangle(..)
                HALFWIDTH, 0,          WIDTH, 60,     wallOpt
            Bodies.rectangle(..)
                HALFWIDTH, HEIGHT,     WIDTH, 60,     wallOpt


    # Notify cells of collisions
    Events.on(..)
        engine, "collisionStart"
        (e) ->
            for pair in e.pairs
                if Math.random() < 0.5
                    pair.bodyA.cell?.collide?(pair.bodyB)
                    pair.bodyB.cell?.collide?(pair.bodyA)
                else
                    pair.bodyB.cell?.collide?(pair.bodyA)
                    pair.bodyA.cell?.collide?(pair.bodyB)

    # Creatures
    let creatureCount = 30
    let creatures = []
        for let i = 0; i < creatureCount; i++
            new Creature()

    let padding = 100
    for creature in creatures
        let x = random(padding, WIDTH - padding)
        let y = random(padding, HEIGHT - padding)
        Composite.rotate(creature.body, random(0, Math.PI * 2), {x: 0, y:0})
        Composite.translate(creature.body, {x,y})
        creature.add()

    #  Main loop
    let previousTime = performance.now()
    let maxDt = 500
    Events.on(..)
        engine, "afterUpdate"
        ->
            let currentTime = performance.now()
            let dt = Math.min(currentTime - previousTime, maxDt)
            previousTime = currentTime

            let dead = []

            for creature in creatures
                if creature.dead
                    dead.push(creature)
                else
                    creature.update(dt)

            for creature in dead
                creatures.remove(creature)