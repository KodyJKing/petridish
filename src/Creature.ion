const
    ion = import 'ion'
    {Matter, Common} = import './'
    {Engine, World, Body, Bodies, Constraint, Events, Composite, Vector} = Matter
    {createSampler, random, randInt, Grid} = Common

const cellSize = 6
const frictionAir = 0.05
const cellSizeSquared = cellSize * cellSize
const
    cellTypes = []
        class Cell
            constructor: (creature, x, y) ->
                @creature = creature
                @body = Bodies.rectangle(..)
                    x * cellSize, y * cellSize
                    cellSize, cellSize, {}
                        render: { fillStyle: @@color }
                @body.cell = @
                Body.setDensity(@body, @@densityFactor * 0.001)
                @constraints = []
            weight: 5
            color: '#F8F8F2'
            densityFactor: 1
            properties:
                edible: true
                remove: ->
                    World.remove(world, @body, true)
                    for constraint in @constraints
                        World.remove(world, constraint, true)
                    @onRemove?()

        class CellRoot extends Cell
            weight: 0
            color: '#FFE792'
            properties:
                onRemove: -> @creature.die()

        class CellMouth extends Cell
            weight: 1
            color: '#F92672'
            densityFactor: 2
            properties:
                collide: (other) ->
                    let otherCell = other.cell
                    if otherCell? and otherCell.creature isnt @creature and otherCell.edible
                        otherCell.remove()
                        @creature.energy++

        class CellPhotosynthesis extends Cell
            weight: 1
            color: '#A6E22E'
            densityFactor: 5
            energyGainRate: 0.00004
            properties:
                update: (dt) ->
                    @creature.energy += @@energyGainRate * dt

        class CellArmor extends Cell
            weight: 2
            color: '#AE81FF'
            densityFactor: 4
            properties:
                edible: false

        class CellThruster extends Cell
            weight: 1
            color: '#FD971F'
            thrust: 0.0000001
            properties:
                update: (dt) ->
                    let force = dt * @@thrust * cellSizeSquared
                    Matter.Body.applyForce(..)
                        @body, @body.position, {}
                            x: Math.cos(@body.angle) * force
                            y: Math.sin(@body.angle) * force

    randomCellType = do ->
        let weights = cellTypes.map((x) -> x.weight)
        let sampler = createSampler(weights)
        return -> cellTypes[sampler()].name

    cellNamespace = do -> {}
        for type in cellTypes
            [type.name]: type

class Genome
    serializable: true
    constructor: ->
        @cells = new Grid()
    properties:
        mutate: ->
            #  Ew, an O(n) op when we only use O(1) of the results!
            let positions = @cells.keys()
            let index = randInt(0, positions.length)
            let [x, y] = positions[index]
            while true
                let xPrime = x + randInt(-1, 2)
                let yPrime = y + randInt(-1, 2)
                if yPrime < 0 or xPrime is 0 and yPrime is 0
                    continue
                @cells.set(xPrime, yPrime, randomCellType())
                return
        build: (creature) ->
            let cellInstances = new Grid()
            for [_x, _y] in @cells.keys()
                let type = cellNamespace[@cells.get(_x, _y)]

                for sign in [1, -1]
                    if _y is 0 and sign is -1
                        continue

                    let x = _x
                    let y = sign * _y

                    let cell = new type(creature, x, y)
                    cellInstances.set(x, y, cell)
                    Composite.add(creature.body, cell.body)

                    for let dx = -1; dx < 2; dx++
                        for let dy = -1; dy < 2; dy++
                            if dx is 0 and dy is 0
                                continue
                            let xPrime = x + dx
                            let yPrime = y + dy
                            let neighbor = cellInstances.get(xPrime, yPrime)
                            if neighbor?
                                let constraint = creature.constrain(..)
                                    cell, neighbor, {}
                                        render: { visible: false }
                                        pointA:
                                            x: dx * cellSize * 0.5
                                            y: dy * cellSize * 0.5
                                        pointB:
                                            x: dx * cellSize * -0.5
                                            y: dy * cellSize * -0.5
                                constraint.lengthFactorSquared = dx * dx + dy * dy

export class Creature
    constructor: (genome = null) ->
        @body = Composite.create()
        if genome?
            @genome = genome
        else
            @genome = new Genome()
            @genome.cells.set(0, 0, 'CellRoot')
            for let i = 0; i < 20; i++
                @genome.mutate()
        @genome.build(@)
        @dead = false
        @energy = 10
    energyLossRate: 0.0002
    properties:
        add: ->
            let padding = 100
            let x = random(padding, WIDTH - padding)
            let y = random(padding, HEIGHT - padding)
            Composite.rotate(@body, random(0, Math.PI * 2), {x: 0, y:0})
            Composite.translate(@body, {x,y})
            World.add(world, @body)
        remove: -> World.remove(world, @body)
        update: (dt) ->
            for body in Composite.allBodies(@body)
                body.cell.update?(dt)

            for constraint in Composite.allConstraints(@body)
                let diff = Vector.sub(constraint.bodyA.position, constraint.bodyB.position)
                let distSq = Vector.magnitudeSquared(diff)
                if distSq > cellSizeSquared * constraint.lengthFactorSquared * 1.3
                    Composite.remove(@body, constraint)

            @energy -= dt * @@energyLossRate
            if @energy <= 0
                console.log('STARVED')
                @die()
            else if @energy >= 20 and creatures.length < maxCreatures
                @reproduce()
        die: ->
            @dead = true
            for constraint in Composite.allConstraints(@body)
                Composite.remove(@body, constraint)
            for body in Composite.allBodies(@body)
                if body.cell.constructor isnt Cell
                    Composite.remove(@body, body)
        reproduce: ->
            @energy -= 10
            let childGenome = ion.deserialize(ion.serialize(@genome), {Genome, Grid})
            childGenome.mutate()
            let child = new Creature(childGenome)
            creatures.push(child)
            child.add()
        constrain: (cellA, cellB, options) ->
            let constraint = Constraint.create(..)
                Object.assign(..)
                    { bodyA: cellA.body, bodyB: cellB.body }
                    options
            cellA.constraints.push(constraint)
            cellB.constraints.push(constraint)
            Composite.add(@body, constraint)
            return constraint